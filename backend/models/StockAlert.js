const mongoose = require('mongoose');

const stockAlertSchema = new mongoose.Schema({
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: true
  },
  productName: {
    type: String,
    required: true
  },
  sku: String,
  alertType: {
    type: String,
    enum: ['low_stock', 'out_of_stock', 'overstock', 'expiring_soon', 'expired', 'reorder_point'],
    required: true
  },
  severity: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    required: true
  },
  currentStock: {
    type: Number,
    required: true,
    min: 0
  },
  threshold: {
    type: Number,
    required: true,
    min: 0
  },
  warehouse: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Warehouse'
  },
  warehouseName: String,
  supplier: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Supplier'
  },
  supplierName: String,
  message: {
    type: String,
    required: true
  },
  isRead: {
    type: Boolean,
    default: false
  },
  isResolved: {
    type: Boolean,
    default: false
  },
  resolvedAt: Date,
  resolvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  resolutionNotes: String,
  autoGenerated: {
    type: Boolean,
    default: true
  },
  notificationSent: {
    type: Boolean,
    default: false
  },
  notificationSentAt: Date,
  emailSent: {
    type: Boolean,
    default: false
  },
  emailSentAt: Date,
  smsSent: {
    type: Boolean,
    default: false
  },
  smsSentAt: Date,
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  tags: [String],
  metadata: {
    type: Map,
    of: mongoose.Schema.Types.Mixed
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for alert age in hours
stockAlertSchema.virtual('ageInHours').get(function() {
  const now = new Date();
  const created = new Date(this.createdAt);
  const diffTime = now - created;
  return Math.floor(diffTime / (1000 * 60 * 60));
});

// Virtual for alert age in days
stockAlertSchema.virtual('ageInDays').get(function() {
  const now = new Date();
  const created = new Date(this.createdAt);
  const diffTime = now - created;
  return Math.floor(diffTime / (1000 * 60 * 60 * 24));
});

// Virtual for severity color
stockAlertSchema.virtual('severityColor').get(function() {
  const severityColors = {
    low: 'blue',
    medium: 'yellow',
    high: 'orange',
    critical: 'red'
  };
  return severityColors[this.severity] || 'gray';
});

// Virtual for alert type icon
stockAlertSchema.virtual('alertTypeIcon').get(function() {
  const typeIcons = {
    low_stock: 'exclamation-triangle',
    out_of_stock: 'x-circle',
    overstock: 'arrow-up',
    expiring_soon: 'clock',
    expired: 'ban',
    reorder_point: 'shopping-cart'
  };
  return typeIcons[this.alertType] || 'bell';
});

// Indexes
stockAlertSchema.index({ product: 1 });
stockAlertSchema.index({ alertType: 1 });
stockAlertSchema.index({ severity: 1 });
stockAlertSchema.index({ isRead: 1 });
stockAlertSchema.index({ isResolved: 1 });
stockAlertSchema.index({ createdAt: -1 });
stockAlertSchema.index({ warehouse: 1 });
stockAlertSchema.index({ supplier: 1 });

// Compound indexes
stockAlertSchema.index({ isResolved: 1, createdAt: -1 });
stockAlertSchema.index({ alertType: 1, severity: 1 });
stockAlertSchema.index({ product: 1, alertType: 1, isResolved: 1 });

// Static method to create low stock alert
stockAlertSchema.statics.createLowStockAlert = async function(product, warehouse = null) {
  const alertType = product.inventory.currentStock === 0 ? 'out_of_stock' : 'low_stock';
  const severity = product.inventory.currentStock === 0 ? 'critical' : 'high';
  
  const message = product.inventory.currentStock === 0
    ? `${product.name} (${product.sku}) is out of stock`
    : `${product.name} (${product.sku}) is running low (${product.inventory.currentStock} units remaining)`;

  const alert = new this({
    product: product._id,
    productName: product.name,
    sku: product.sku,
    alertType,
    severity,
    currentStock: product.inventory.currentStock,
    threshold: product.inventory.minStock,
    warehouse: warehouse?._id,
    warehouseName: warehouse?.name,
    supplier: product.supplier,
    supplierName: product.supplier?.name,
    message,
    autoGenerated: true
  });

  return alert.save();
};

// Static method to create overstock alert
stockAlertSchema.statics.createOverstockAlert = async function(product, warehouse = null) {
  const alert = new this({
    product: product._id,
    productName: product.name,
    sku: product.sku,
    alertType: 'overstock',
    severity: 'medium',
    currentStock: product.inventory.currentStock,
    threshold: product.inventory.maxStock,
    warehouse: warehouse?._id,
    warehouseName: warehouse?.name,
    supplier: product.supplier,
    supplierName: product.supplier?.name,
    message: `${product.name} (${product.sku}) is overstocked (${product.inventory.currentStock} units, max: ${product.inventory.maxStock})`,
    autoGenerated: true
  });

  return alert.save();
};

// Static method to create expiring alert
stockAlertSchema.statics.createExpiringAlert = async function(product, daysUntilExpiry, warehouse = null) {
  const alertType = daysUntilExpiry <= 0 ? 'expired' : 'expiring_soon';
  const severity = daysUntilExpiry <= 0 ? 'critical' : daysUntilExpiry <= 7 ? 'high' : 'medium';
  
  const message = daysUntilExpiry <= 0
    ? `${product.name} (${product.sku}) has expired`
    : `${product.name} (${product.sku}) expires in ${daysUntilExpiry} days`;

  const alert = new this({
    product: product._id,
    productName: product.name,
    sku: product.sku,
    alertType,
    severity,
    currentStock: product.inventory.currentStock,
    threshold: 0,
    warehouse: warehouse?._id,
    warehouseName: warehouse?.name,
    supplier: product.supplier,
    supplierName: product.supplier?.name,
    message,
    autoGenerated: true,
    metadata: {
      daysUntilExpiry,
      expiryDate: new Date(Date.now() + daysUntilExpiry * 24 * 60 * 60 * 1000)
    }
  });

  return alert.save();
};

// Static method to get unresolved alerts
stockAlertSchema.statics.getUnresolvedAlerts = function(filters = {}) {
  const query = { isResolved: false };
  
  if (filters.alertType) query.alertType = filters.alertType;
  if (filters.severity) query.severity = filters.severity;
  if (filters.warehouse) query.warehouse = filters.warehouse;
  if (filters.supplier) query.supplier = filters.supplier;
  if (filters.isRead !== undefined) query.isRead = filters.isRead;

  return this.find(query)
    .populate('product', 'name sku')
    .populate('warehouse', 'name code')
    .populate('supplier', 'name')
    .populate('createdBy', 'firstName lastName')
    .populate('resolvedBy', 'firstName lastName')
    .sort({ severity: -1, createdAt: -1 });
};

// Static method to get alert statistics
stockAlertSchema.statics.getAlertStatistics = async function() {
  const stats = await this.aggregate([
    {
      $group: {
        _id: null,
        totalAlerts: { $sum: 1 },
        unresolvedAlerts: {
          $sum: { $cond: [{ $eq: ['$isResolved', false] }, 1, 0] }
        },
        criticalAlerts: {
          $sum: {
            $cond: [
              { $and: [{ $eq: ['$severity', 'critical'] }, { $eq: ['$isResolved', false] }] },
              1,
              0
            ]
          }
        },
        highAlerts: {
          $sum: {
            $cond: [
              { $and: [{ $eq: ['$severity', 'high'] }, { $eq: ['$isResolved', false] }] },
              1,
              0
            ]
          }
        },
        lowStockAlerts: {
          $sum: {
            $cond: [
              { $and: [{ $eq: ['$alertType', 'low_stock'] }, { $eq: ['$isResolved', false] }] },
              1,
              0
            ]
          }
        },
        outOfStockAlerts: {
          $sum: {
            $cond: [
              { $and: [{ $eq: ['$alertType', 'out_of_stock'] }, { $eq: ['$isResolved', false] }] },
              1,
              0
            ]
          }
        },
        expiringAlerts: {
          $sum: {
            $cond: [
              { $and: [{ $eq: ['$alertType', 'expiring_soon'] }, { $eq: ['$isResolved', false] }] },
              1,
              0
            ]
          }
        }
      }
    }
  ]);

  if (stats.length === 0) {
    return {
      totalAlerts: 0,
      unresolvedAlerts: 0,
      criticalAlerts: 0,
      highAlerts: 0,
      lowStockAlerts: 0,
      outOfStockAlerts: 0,
      expiringAlerts: 0
    };
  }

  return stats[0];
};

// Instance method to mark as read
stockAlertSchema.methods.markAsRead = function() {
  this.isRead = true;
  return this.save();
};

// Instance method to resolve alert
stockAlertSchema.methods.resolve = function(resolvedBy, resolutionNotes = '') {
  this.isResolved = true;
  this.resolvedAt = new Date();
  this.resolvedBy = resolvedBy;
  this.resolutionNotes = resolutionNotes;
  return this.save();
};

module.exports = mongoose.model('StockAlert', stockAlertSchema);
